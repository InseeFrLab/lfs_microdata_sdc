---
title: "Data exploration of LFS armenian data"
author: "MS4"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: tactile #cayman
    highlight: github
    toc: true
    toc_depth: 5
---

```{r}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo = FALSE}
packs <- c("xlsx","dplyr","tidyr","sdcMicro","archive","ggplo2")
p <- sapply(packs, install.packages)
p <- lapply(packs,function(p) suppressPackageStartupMessages(library(p,character.only = TRUE)))
rm(p)
# rm(list=ls())
```

### Prepare data :

```{r}

download.file(
  destfile = "data/lfs_micro_arm_2020.7z",
  url = "https://www.armstat.am/file/doc/99528268.7z"
)
archive::archive_extract("data/lfs_micro_arm_2020.7z",dir = "data/")
# To read it 
lfs_micro_arm_2020 <- haven::read_spss("data/LFS_2020_2020 Dataset_Residents.sav")

lfs_micro_arm_2020 <-
  lfs_micro_arm_2020 %>% 
  mutate(
    id_hh = as.numeric(substr(IDmem,1,nchar(IDmem)-2)), # concatenation of month + questionnaire_num
    id_indiv = substr(IDmem,nchar(IDmem)-1,nchar(IDmem))
  ) 

```

Household identification :

A6_month : month of survey
A1 : questionnaire number

Quasi-identifying variables :

- B5, B6 : Date of birth
- B3 : Gender
- A3 : Geographical Area (Marz)
- B11 : Marital Status 
- B7 : Diploma

Sensitive variables 

- E15 : Income
- C2 : country of citizenship
- LU1_unemployed : unemployment

```{r}
lfs_micro_subset <-
  lfs_micro_arm_2020 %>%
  select(id_hh,id_indiv,B5,B6,B3,A3,B11,B7,E15,C2,LU1_unemployed,WeightsCalib_year) %>% 
  mutate(
    dob = paste0(B5,"_",B6), # date of birth
    LU1_unemployed = as.factor(ifelse(is.na(LU1_unemployed),0,1)) 
         ) %>% 
  select(-B5,-B6)
```


### A simple way to apply PRAM

```{r}
pram_1 <- pram(
  lfs_micro_subset,
  variables = "LU1_unemployed"
)

str(pram_1,1) # It is not a sdc Micro object, list of variables xwith attributes

attributes(pram_1)
attr(pram_1,"summary")
attr(pram_1,"pram_params")

# build data based on the results
data_pram <- 
  do.call(cbind,pram_1) %>%
  data.frame()

# Original count
data_pram %>% 
  group_by(LU1_unemployed) %>% 
  count()

# the modify variable is suffixed by "_pram"
data_pram %>% 
  group_by(LU1_unemployed_pram) %>% 
  count()

data_pram %>% 
  group_by(LU1_unemployed,LU1_unemployed_pram) %>% 
  count() %>% 
  ungroup() %>% 
  pivot_wider(
    names_from = LU1_unemployed_pram,
    values_from = n
    )
```

### Define the pram parameters  

You can choose your matrix, be careful it is not invariant pram anymore, counts obtained with perturbed values are biased
```{r}


mat <- matrix(c(0.3,0.7,0.2,0.8),nrow = 2,byrow = TRUE)
row.names(mat) <- colnames(mat) <- levels(lfs_micro_subset$LU1_unemployed)


pram <- pram(
  lfs_micro_subset,
  variables = "LU1_unemployed",
  pd = mat,
  alpha = NA
)

```

Invariant Pram is automatically applied if only one coefficient is given for pd  (minimal diagonal value coefficient) (it can be seen as the level of utility we want to keep)

The alpha parameters is linked to the invariant pram method see "The Analysis of Data Perturbed by PRAM
A.D.L. van den Hout" and give also an idea of the level of pertubation we want to achieve. it lies between the 0,1 intervals, default value  is 0.5


```{r}
set.seed(12345)

pram1 <- pram(
  lfs_micro_subset,
  variables = "LU1_unemployed",
  pd = c(0.5), # can be a matrix or a minimal diagonal value
  alpha = 0.2  # must lie between 0 and 1, its a parameter we can choose for invariant PRAM
)


attr(pram1,"pram_params")


pram2 <- pram(
  lfs_micro_subset,
  variables = "LU1_unemployed",
  pd = c(0.5), # can be a matrix or a minimal diagonal value
  alpha = 0.99  # must lie between 0 and 1, its a parameter we can choose for invariant PRAM
)


attr(pram2,"pram_params")
# pd = param in entry, RS, sresulting P matrix


# verification of invariant pram
initial_count = table(lfs_micro_subset$LU1_unemployed)
pram_matrix1 = attr(pram1,"pram_params")$LU1_unemployed$Rs 
pram_matrix2 = attr(pram2,"pram_params")$LU1_unemployed$Rs 

initial_count

initial_count %*% pram_matrix1 
initial_count %*% pram_matrix2 


table(pram2$LU1_unemployed_pram)
table(pram1$LU1_unemployed_pram)

table(pram1$LU1_unemployed,pram1$LU1_unemployed_pram)
table(pram2$LU1_unemployed,pram2$LU1_unemployed_pram)


```

Stratification is not useful here since, we apply the same matrix independently to each sub groups

### How to measure the information loss ?

The loss of information should not be measured in terms of the random realisation generated by the method but rather through the characteristics of the transition matrix P and the initial distribution of individuals in the categories of the variable

One can calculate for each category the quantity : $$P0(k) =\frac{P(\xi = k | X = k)}{P(\xi \ne k | X = k)}=  \frac{p_{kk}P(\xi = k)}{\sum_{l \neq k}p_{lk}P(\xi=l)}$$ 

```{r}


p1  <-  lfs_micro_subset %>% 
      mutate(
        LU1_num = as.numeric(lfs_micro_subset$LU1_unemployed)-1,
        LU1_pond = WeightsCalib_year * LU1_num
        ) %>% 
      group_by() %>% 
      summarise(LU1_pond = sum(LU1_pond)/sum(WeightsCalib_year)) %>% 
      pull()
    
p0 <-  1 - p1

calculate_posterior_OR <- function(m){
  
    p11 = m[2,2]
    p01 = m[1,2]
    
    p11*p1/p01*p0 
}

calculate_posterior_OR(m)

m1 <- pram_matrix1
calculate_posterior_OR(m1) 
```
This can be interpreted as follows: After applying PRAM to the data with the m1 matrix, when a row has a 1, the probability that the observed data has not been disturbed is 6 times greater than the probability that the observed data has been disturbed. The dataset is not sufficiently protected, but with m2 matrix, the dataset is much more perturbated 

```{r}

m2 <- pram_matrix2
calculate_posterior_OR(m2)

```

we can try to observe the evolution of the value of the posterior ods ratios as a function of the defined matrix

```{r}
list_param <- seq(0.01,1,0.05)
list_matrices <- lapply(list_param,
                        function(theta){
                          matrix(c(1-theta,theta,theta,1-theta),nrow = 2, byrow = TRUE)
                          }
                        )
calculate_posterior_OR_vect <- Vectorize(calculate_posterior_OR)

data.frame(y = calculate_posterior_OR_vect(list_matrices), x = list_param) %>% 
  ggplot() +
  geom_point(mapping = aes(x=x, y=y),col= "red")+
  ggtitle("Posterior ods-ratio")
  

```


### Applying PRAM on a SDC_micro_obj 

Prepare the sdc micro object
```{r}
selectedKeyVars = c('dob','A3','B3','B7','B11')

# weight variable
selectedWeightVar = c('WeightsCalib_year')

# selected pram variables
selectedPramVars = c('LU1_unemployed')

# household id variable (cluster)
selectedHouseholdID = c('id_hh')

sdcInitial <- createSdcObj(
  dat = lfs_micro_subset,
  keyVars     = selectedKeyVars,
  weightVar   = selectedWeightVar,
  pramVars    = selectedPramVars,
  hhId        = selectedHouseholdID,
  seed = 12345
)

str(sdcInitial,2)
```

```{r}

pram_2  <- pram(sdcInitial,variables = NULL,strata_variables = NULL)
str(pram_2,1)
# If argument 'variables' is NULL, all variables from slot 'pramVars' will be used if possible.

pram_2@origData %>%
  group_by(LU1_unemployed) %>%
  count()

# PRAM count 
pram_2@manipPramVars %>%
  group_by(LU1_unemployed) %>%
  count()

# What happens ?
table(
  pram_2@manipPramVars$LU1_unemployed,
  pram_2@origData$LU1_unemployed
  )
```

Which parameters has been used by default ?
```{r}

sdcInitial@pram
pram_2@pram

# P Matrix
pram_2@pram$params$LU1_unemployed$Rs

# Transitions
pram_2@pram$transitions$LU1_unemployed

```











